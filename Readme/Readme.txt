
* 目前进度
*********************************************************************************
准备语音模块的功能复现、封装


* 2024/10/12
*********************************************************************************
移植了OnceDis.c/.h 用于首次（单次）显示固定文本
成功移植max30102芯片驱动程序和其心率血氧计算的程序max30102.c/.h  heart_spo2.c/.h
完善了测心率和测血氧的功能


* 2024/10/11
*********************************************************************************
移植了GPIOExti.c,添加配置按键外部中断,外部中断服务函数和回调函数在该文件下。
按键1已更改为外部中断扫描按键。
下一步开发功能：健康与运动->血氧和心率计算和显示


* 目前已开发功能
*********************************************************************************
已开发完善的功能
	1.标准时间的显示（年月日，时分秒，星期）
	2.菜单的显示（3级菜单）
	3.菜单项功能的实现
		1) 息屏设置：修改定时休眠时间
			休眠模式实际指stm32进入了待机模式（以下统称为休眠模式）
				进入休眠模式的2种方式：
					1.按下按键3手动进入休眠模式
					2.定时进入休眠模式，定时时间到mcu自动进入休眠模式
					进入待机模式后，除了备份寄存器外，所有寄存器内容均丢失，只有备份电路维持供电
				退出休眠模式的2种方式：
					1.按下按键WKUP，唤醒标志位被硬件置位，手动唤醒mcu
					2.闹钟时间到，产生闹钟中断，硬件置位唤醒标志位，mcu被自动唤醒
					mcu从休眠模式下被唤醒后的代码执行相当于复位后的执行，除了电源控制/状态寄存器，其他寄存器都被复位
					
		2) 时间设置：修改标准时间
		3) 闹钟设置：设置闹钟
		4) 秒表：秒表计时
		5) 手电筒：LED模拟实现
		6) 测心率：外接max30102芯片，通过红光样本数据计算得出心率
		7) 测血氧：外接max30102芯片，通过红外光样本数据计算得出血氧
	4.定时休眠实现低功耗，在标准时间显示界面时，系统定时进入休眠(待机模式)

* 尚未开发的功能
********************************************************************************
待开发的功能
	1.体温测量
	2.智能语音识别
	
* 优化代码
********************************************************************************
1.oled文件夹下新增onceDis.c/.h文件
	作用：封装" 首次执行且只执行一次的 "代码
	好处：方便更新和维护代码，代码结构更清晰



* 修改/更新/维护前请看
*********************************************************************************
智能手表项目目前已用外设
	片上外设
		通用定时器2/3/4
			定时器2：时间闪烁显示
			定时器3：秒表计数
			定时器4：定时休眠计时
		RTC实时时钟
			备份寄存器1-6 (余7-10未用)
				备份寄存器1：保存首次开启RTC设置标准时间的状态，确保复位/唤醒不会重置时间
				备份寄存器2-5：保存日期数据（年-月-日-星期），确保复位/唤醒后日期显示正确
				备份寄存器6：保存定时休眠时间，确保唤醒/复位后定时休眠时间与之前保持一致
				备份寄存器7：保存设置闹钟标志，用于mcu被闹钟唤醒复位后仍能执行产生闹钟中断后操作
			PA0使能唤醒引脚，上升沿触发，强制下拉输入
	
	片外扩展外设
		LED0/1/2
			未用到项目中，可做调试
		按键Key0/1/2/3/WKUP (余Key0未用)
			Key1：初始化菜单、执行菜单项功能函数
			Key2：切换修改标准时间/闹钟的位、切换定时休眠时间
			Key3：直接进入休眠模式
			KeyWKUP：接唤醒引脚PA0，退出待机模式，复位执行主程序
		蜂鸣器Beep
			Beep：有源蜂鸣器，闹钟时间到发声
		旋转编码器Encoder
			Encoder：修改标准时间和闹钟加或减、菜单滑动
		显示屏OLED 0.96
			OLED：显示标准时间、菜单等功能界面
			

* 开发中遇到的问题
**********************************************************************************
	
菜单模块

	菜单项用malloc()动态申请分配内存
	
		问题：malloc()函数动态分配内存失败，返回NULL
		
			原因1(可能)：
				内存不足，stm32分配的堆内存太小，导致动态分配内存失败。
				一个菜单项menuItem占用32字节，stm32默认分配512字节，其真实可用的只有一半，也就是256字节
				256字节只能分配给8个menuItem。
				解决办法：在启动文件中修改Heap_Size的值，增加可供分配的堆内存
				
			原因2(可能)：
				菜单项结构体类型menuItem和createMenuItem()函数中的局部变量menuItem重名了
				源代码：menuItemP menuItem = (menuItemP)malloc(sizeof(menuItem));
				解决办法：修改局部变量名，不要重名。
			
			原因3(指针越界,网上案例):
				用malloc申请内存后，返回的指针类型为(unsigned char*)，后面将该指针强转为了(unsigned int*)，
				指针指向的变量类型发生了改变，其占用内存的大小发生了变化，可能会对未分配的内存区域进行操作，
				进而造成指针越界，导致下次使用malloc申请内存失败。
				解决办法：不要对申请到的指针类型二次强转
				
			我采用了原因1和2的解决方法后，问题就解决了
			
	菜单显示
	
		问题：返回显示父菜单（上一级菜单）时，如何恢复原样显示？（进入时什么样，返回去也是什么样）
			
			要点：
				返回显示后，要求箭头指向的菜单项是父菜单项，且所在行与进入时一致。菜单的菜单项也与进入时的位置和名字一致。
			
			解决方法：
				在箭头结构体中加入superItemLine属性，用于进入显示子菜单时保存父菜单项的所在行，在返回显示时，就能根据
				箭头指针保存的superItemLine确定父菜单项的所在行，和父菜单项的ID结合运算便可以确定其首行显示的菜单项的
				ID，进而恢复显示进入时的原样。
			
			引出的新问题：
				我这里只用了一级菜单，因此只用保存一级父菜单项的所在行，若是有多级菜单，比如二级菜单，当从一级菜单进入
				二级菜单时，要保存一级父菜单项的所在行，这时并不返回，而是继续进入二级菜单的子菜单显示，就要保存二级
				父菜单项的所在行，也就是要保存2个父菜单项的所在行，而箭头指针中只有一个变量保存父菜单项所在行，显然
				这样会覆盖一级父菜单项的所在行，而导致无法恢复一级菜单的原样。
				
				解决方法：
				1.在箭头结构体中修改superItemLine属性，改为一个数组，来存储各个级别父菜单项的所在行，再添加一个
				enum menuLevel的枚举类型，其定义了菜单级别，在箭头结构体中加入该枚举类型，指明箭头指向的菜单项的菜单
				级别，这样在进入和返回显示时就能唯一确定各级别父菜单项的所在行了。
			
			这里我采用了数组的方式存储多级菜单父项的所在行信息，成功解决了"二级及二级以上多级目录保存现场，返回恢复现场"的问题
			
	菜单项功能实现
	
		秒表功能
		
			问题：
				进入秒表功能界面后，在转动旋转编码器后，切换箭头指向菜单项，屏幕显示出现乱码或显示多于信息，旋转速度
				过快甚至会出现显示位置错位的情况。
				
			原因：
				在秒表功能界面，主程序一直在调用显示秒表的函数，也就是一直在调用OLED显示函数，当要切换菜单时，
				需要扭动旋转编码器，这时会触发外部中断，中断打断了主程序的执行，可能这时正在调用OLED显示函数，
				而该函数并没有执行完毕就被中断打断了，虽然保存了现场，但在旋转编码器的外部中断服务函数中，调用了
				显示菜单函数，函数内部调用了OLED显示函数，也就是切换菜单显示的操作是在中断服务函数里执行的，OLED显示
				函数在中断中也被调用，也就是对OLED内的寄存器进行了操作，导致进入中断前保存的现场被破坏了，因此中断
				服务函数执行完毕回到主程序继续执行OLED显示函数时，就会出现异常现象，OLED就会显示异常。
				
				* 简述：OLED函数在主程序中未执行完毕，被中断打断后，在中断服务函数中也执行了对OLED外设操作的函数，导致
				保存的现场被破坏，进而导致OLED显示异常。
				* 主程序正在执行操作的外设，在可能会打断主程序运行的中断中不能对该外设进行操作
				
			解决方法：
			
				在旋转编码器的外部中断服务函数中不再执行OLED显示函数，不再直接操作外设，定义枚举类型变量、标志位等，
				在中断服务函数中改变这些变量或标志位的值，并提供get函数给主程序调用获取变量和标志位，判断变量和标志位
				进而对外设做出不同的操作。
			
	闹钟和待机模式
	
		问题：
			闹钟唤醒mcu后，复位执行主程序，没有执行闹钟中断服务程序，导致蜂鸣器没有发声
		
		原因：
			mcu在待机模式下，中断是不供电的，而且mcu被唤醒后，除了电源控制/状态寄存器外，其余寄存器均被复位，
			相当于执行mcu复位后的操作，中断也被复位，因此不会执行中断服务函数，进而闹钟中断应该产生的操作没有
			被执行（蜂鸣器没有发声）
		
		解决办法：
			根据用户手册，在WKUP外部引脚产生的上升沿或闹钟中断时，mcu被唤醒，且唤醒标志位WU被硬件置位
			故在设置闹钟的函数setAlarm中向备份寄存器DR7写入0x01，然后在RTC初始化函数中，
			读取电源控制/状态寄存器的唤醒标志位，清除唤醒标志位和进入待机标志位，然后读取备份寄存器DR7，
			若读到0x01则表示该唤醒是由闹钟中断引起的，进而置位闹钟响标志位，清除备份寄存器DR7存储的设置闹钟标志。
		
		* 新发现的bug：
			在设置完闹钟后，进入了休眠模式，手动唤醒后，蜂鸣器响了，说明闹钟标志被置位了。
		
		* 原因：
			在MyRTC.c初始化函数中判断是否是闹钟唤醒的代码的问题，判断条件不能完全判断是闹钟唤醒，也就是手动唤醒
			也能导致闹钟标志被置位。
		
		* 解决方法：
			在设置闹钟setAlarm函数中，向备份寄存器DR7中写入闹钟时间时分秒的总和左移1位+0x01，在RTC初始化函数中，
			求出当前时间时分秒的总和，增加判断条件：当前时分秒的总和是否等于读取备份寄存器DR7右移1位的值，若相等
			则说明真的是闹钟唤醒，否则不是。
		
			* 最终成功修复了新bug。
			
			
				
				
				
				
				
				
				